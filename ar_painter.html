<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ARç¥ç¬”é©¬è‰¯ - æ·±åº¦æ„Ÿåº”ç‰ˆ</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        :root { --accent: #00ffcc; }
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #video-container { position: fixed; width: 100vw; height: 100vh; }
        .mirrored { transform: scaleX(-1); }
        video { width: 100%; height: 100%; object-fit: cover; }
        #output_canvas { position: absolute; top: 0; left: 0; z-index: 5; pointer-events: none; }

        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .status-tag {
            position: fixed; top: 20px; right: 20px; padding: 8px 15px;
            background: rgba(0,0,0,0.6); color: white; border-radius: 20px;
            font-size: 12px; z-index: 10; border: 1px solid var(--accent);
        }

        /* åº•éƒ¨æ§åˆ¶é¢æ¿ */
        .panel {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            z-index: 10; width: 90%; max-width: 500px;
            display: flex; flex-direction: column; gap: 15px;
        }
        .mode-switch {
            display: flex; background: rgba(0,0,0,0.8); border-radius: 12px; overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .mode-btn {
            flex: 1; padding: 15px; color: white; border: none; background: none;
            cursor: pointer; font-weight: bold; transition: 0.3s;
        }
        .mode-btn.active { background: var(--accent); color: #000; }
        
        .tool-bar { display: flex; justify-content: space-between; gap: 10px; }
        .circle-btn {
            width: 50px; height: 50px; border-radius: 50%; border: 2px solid white;
            background: rgba(0,0,0,0.5); color: white; display: flex; 
            align-items: center; justify-content: center; font-size: 20px;
        }
    </style>
</head>
<body>

    <div id="status" class="status-tag">ç­‰å¾…æ‰‹åŠ¿...</div>

    <div id="video-container" class="mirrored">
        <video id="input_video" playsinline></video>
    </div>
    <canvas id="output_canvas"></canvas>

    <div class="panel">
        <div class="mode-switch">
            <button id="btn-move" class="mode-btn active" onclick="setMode('move')">ğŸ–ï¸ ç§»åŠ¨æ¨¡å¼</button>
            <button id="btn-draw" class="mode-btn" onclick="setMode('draw')">âœï¸ ç»˜ç”»æ¨¡å¼</button>
        </div>

        <div class="tool-bar">
            <button class="circle-btn" onclick="toggleMirror()">ğŸª</button>
            <button class="circle-btn" onclick="switchCamera()">ğŸ”„</button>
            <button class="circle-btn" onclick="initAR()" id="ar-indicator">ğŸ“¡</button>
            <button class="circle-btn" onclick="clearCanvas()" style="border-color: #ff4757;">ğŸ—‘ï¸</button>
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const videoContainer = document.getElementById('video-container');
        let isMirrored = true;
        let isARActive = false;
        let paintMode = 'move'; // 'move' or 'draw'
        let currentColor = 0x00ffcc;
        
        // --- Three.js åœºæ™¯è®¾ç½® ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('output_canvas'), alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.position.set(0, 0, 0);

        // --- æ ¸å¿ƒé€»è¾‘ï¼šåŠ¨æ€ç²—ç»†ç”»ç¬” ---
        let currentStroke = null;
        let strokePoints = [];

        function createNewStroke(startPoint, radius) {
            // ä½¿ç”¨ Sphere æ¨¡æ‹Ÿç”»ç¬”å°–ç«¯ï¼Œåç»­ç”¨å¤šä¸ª Sphere è¿æˆçº¿å®ç°ä¸æ»‘ç²—ç»†å˜åŒ–
            const geometry = new THREE.SphereGeometry(radius, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: currentColor });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(startPoint);
            scene.add(mesh);
            return mesh;
        }

        // --- æ‰‹åŠ¿è¯†åˆ« ---
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.8, minTrackingConfidence: 0.8 });

        hands.onResults((results) => {
            const statusLabel = document.getElementById('status');
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const indexTip = results.multiHandLandmarks[0][8]; // é£ŸæŒ‡æŒ‡å°–
                
                // 1. åæ ‡é•œåƒä¸æ˜ å°„
                let x = (indexTip.x - 0.5) * 10;
                let y = -(indexTip.y - 0.5) * 10;
                if (isMirrored) x = -x;

                // 2. æ ¸å¿ƒï¼šæ ¹æ®æ·±åº¦ Z åˆ‡æ¢ç²—ç»†
                // indexTip.z è¶Šå°ï¼ˆè´Ÿæ•°è¶Šæ·±ï¼‰è¡¨ç¤ºç¦»é•œå¤´è¶Šè¿‘ã€‚
                // æˆ‘ä»¬å°†å…¶æ˜ å°„ä¸ºç”»ç¬”åŠå¾„ã€‚
                const rawZ = indexTip.z; 
                const zPos = -rawZ * 20 - 5; 
                const brushRadius = Math.max(0.02, Math.abs(rawZ) * 1.2); 

                statusLabel.innerText = `æ·±åº¦: ${rawZ.toFixed(2)} | ç²—ç»†: ${brushRadius.toFixed(2)}`;

                // 3. ç»˜ç”»è§¦å‘é€»è¾‘
                if (paintMode === 'draw') {
                    // å°†å±å¹•ç‚¹è½¬ä¸ºä¸–ç•Œç©ºé—´åæ ‡ï¼ˆè€ƒè™‘ç›¸æœºæ—‹è½¬ï¼‰
                    const worldPos = new THREE.Vector3(x, y, zPos).applyQuaternion(camera.quaternion);
                    
                    // æ¯ä¸€å¸§ç”»ä¸€ä¸ªå°çƒï¼Œå½¢æˆè¿ç»­çš„ç«‹ä½“çº¿æ¡
                    createNewStroke(worldPos, brushRadius);
                }
            } else {
                statusLabel.innerText = "æœªæ£€æµ‹åˆ°æ‰‹æŒ‡";
            }
        });

        // --- äº¤äº’æ§åˆ¶ ---
        function setMode(mode) {
            paintMode = mode;
            document.getElementById('btn-move').classList.toggle('active', mode === 'move');
            document.getElementById('btn-draw').classList.toggle('active', mode === 'draw');
        }

        function toggleMirror() {
            isMirrored = !isMirrored;
            videoContainer.classList.toggle('mirrored', isMirrored);
        }

        function initAR() {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(s => { if(s==='granted') startAR(); });
            } else { startAR(); }
        }

        function startAR() {
            isARActive = !isARActive;
            document.getElementById('ar-indicator').style.borderColor = isARActive ? 'var(--accent)' : 'white';
            const handler = (e) => {
                if(!isARActive) return;
                const alpha = THREE.MathUtils.degToRad(e.alpha);
                const beta = THREE.MathUtils.degToRad(e.beta);
                const gamma = THREE.MathUtils.degToRad(e.gamma);
                camera.quaternion.setFromEuler(new THREE.Euler(beta, alpha, -gamma, 'YXZ'));
            };
            window.addEventListener('deviceorientation', handler);
        }

        async function switchCamera() {
            facingMode = (facingMode === "user") ? "environment" : "user";
            isMirrored = (facingMode === "user");
            videoContainer.classList.toggle('mirrored', isMirrored);
            if (cameraControl) { await cameraControl.stop(); startCamera(); }
        }

        let facingMode = "user";
        let cameraControl;
        function startCamera() {
            cameraControl = new Camera(videoElement, {
                onFrame: async () => { await hands.send({ image: videoElement }); },
                width: 1280, height: 720, facingMode: facingMode
            });
            cameraControl.start();
        }

        window.clearCanvas = () => { while(scene.children.length > 0) scene.remove(scene.children[0]); };

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        startCamera();
        animate();
    </script>
</body>
</html>
