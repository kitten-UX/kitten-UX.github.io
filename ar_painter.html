<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR/VR ç¥ç¬”é©¬è‰¯ Pro</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        :root { --accent: #00ffcc; }
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        
        /* è§†é¢‘å›¾å±‚ */
        #video-container { position: fixed; width: 100vw; height: 100vh; z-index: 1; }
        .mirrored { transform: scaleX(-1); }
        video { width: 100%; height: 100%; object-fit: cover; }

        /* ç”»å¸ƒå±‚ */
        canvas { position: absolute; top: 0; left: 0; z-index: 5; pointer-events: none; }

        /* UI é¢æ¿ */
        .ui-overlay {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            z-index: 100; width: 95%; max-width: 600px; display: flex; flex-direction: column; gap: 10px;
        }
        .vr-mode-ui { display: none; } /* VRæ¨¡å¼ä¸‹éšè—UI */

        .controls-row { display: flex; gap: 8px; justify-content: center; }
        .btn {
            background: rgba(0,0,0,0.7); color: white; border: 1px solid rgba(255,255,255,0.3);
            padding: 12px; border-radius: 12px; flex: 1; font-size: 14px;
        }
        .btn.active { background: var(--accent); color: #000; font-weight: bold; }
        
        .color-pills { display: flex; gap: 10px; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 50px; justify-content: center; }
        .pill { width: 30px; height: 30px; border-radius: 50%; border: 2px solid white; cursor: pointer; }
        
        /* VR åˆ†å±é®ç½© */
        #vr-cursor { 
            display: none; position: fixed; top: 50%; left: 50%; 
            width: 10px; height: 10px; background: red; border-radius: 50%; transform: translate(-50%, -50%); z-index: 200;
        }
    </style>
</head>
<body>

    <div id="video-container" class="mirrored">
        <video id="input_video" playsinline></video>
    </div>
    <canvas id="output_canvas"></canvas>
    <div id="vr-cursor"></div>

    <div class="ui-overlay" id="main-ui">
        <div class="color-pills">
            <div class="pill" style="background:#ff3e3e" onclick="setColor('#ff3e3e')"></div>
            <div class="pill" style="background:#3eff8b" onclick="setColor('#3eff8b')"></div>
            <div class="pill" style="background:#3eabff" onclick="setColor('#3eabff')"></div>
            <div class="pill" style="background:#ffff3e" onclick="setColor('#ffff3e')"></div>
            <div class="pill" style="background:#ffffff" onclick="setColor('#ffffff')"></div>
        </div>
        <div class="controls-row">
            <button class="btn" id="draw-toggle" onclick="toggleDraw()">ğŸ–ï¸ ç§»åŠ¨ä¸­</button>
            <button class="btn" onclick="toggleVR()">ğŸ¥½ VRæ¨¡å¼</button>
            <button class="btn" onclick="switchCamera()">ğŸ”„ é•œå¤´</button>
            <button class="btn" onclick="clearAll()" style="color:#ff4757">ğŸ—‘ï¸ æ¸…ç©º</button>
        </div>
    </div>

    <script>
        // --- åˆå§‹åŒ–å˜é‡ ---
        const videoElement = document.getElementById('input_video');
        const videoContainer = document.getElementById('video-container');
        let isMirrored = true, isDrawing = false, isVR = false, isAR = false;
        let currentColor = 0x3eff8b, lastPoint = null, facingMode = "user";

        // --- Three.js æ ¸å¿ƒ ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('output_canvas'), alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.autoClear = false; // VR åŒçœ¼æ¸²æŸ“éœ€è¦

        // --- è¿è´¯ç”»ç¬”ç®—æ³• ---
        function drawSmoothLine(currentPos, radius) {
            const geometry = new THREE.SphereGeometry(radius, 12, 12);
            const material = new THREE.MeshBasicMaterial({ color: currentColor });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.copy(currentPos);
            scene.add(sphere);

            // å¦‚æœæœ‰ä¸Šä¸€ä¸ªç‚¹ï¼Œåœ¨ä¸¤ç‚¹é—´å¡«å……ï¼Œé˜²æ­¢æ–­è£‚
            if (lastPoint) {
                const dist = lastPoint.distanceTo(currentPos);
                const steps = Math.ceil(dist / (radius * 0.5)); // æ ¹æ®ç²—ç»†å†³å®šå¡«å……å¯†åº¦
                for (let i = 1; i < steps; i++) {
                    const lerpSphere = sphere.clone();
                    lerpSphere.position.lerpVectors(lastPoint, currentPos, i / steps);
                    scene.add(lerpSphere);
                }
            }
            lastPoint = currentPos.clone();
        }

        // --- MediaPipe æ‰‹åŠ¿è¯†åˆ« ---
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const tip = results.multiHandLandmarks[0][8];
                
                // åæ ‡è®¡ç®—
                let x = (tip.x - 0.5) * 12;
                let y = -(tip.y - 0.5) * 10;
                if (isMirrored) x = -x;
                
                // ç²—ç»†éšè·ç¦»å˜åŒ–ï¼štip.z è¶Šè´Ÿï¼ˆç¦»é•œå¤´è¶Šè¿‘ï¼‰ï¼Œçº¿æ¡è¶Šç²—
                const z = -tip.z * 20 - 5;
                const radius = Math.max(0.02, Math.abs(tip.z) * 1.5);

                if (isDrawing) {
                    const pos = new THREE.Vector3(x, y, z).applyQuaternion(camera.quaternion);
                    drawSmoothLine(pos, radius);
                } else {
                    lastPoint = null;
                }
            }
        });

        // --- äº¤äº’åŠŸèƒ½ ---
        function toggleDraw() {
            isDrawing = !isDrawing;
            const btn = document.getElementById('draw-toggle');
            btn.innerText = isDrawing ? "âœï¸ ç»˜ç”»ä¸­" : "ğŸ–ï¸ ç§»åŠ¨ä¸­";
            btn.classList.toggle('active', isDrawing);
        }

        function setColor(hex) { currentColor = new THREE.Color(hex).getHex(); }
        
        function clearAll() { while(scene.children.length > 0) scene.remove(scene.children[0]); }

        function toggleVR() {
            isVR = !isVR;
            document.getElementById('main-ui').style.display = isVR ? 'none' : 'flex';
            if (isVR) {
                // VRæ¨¡å¼è‡ªåŠ¨å¼€å¯ä¼ æ„Ÿå™¨
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission().then(s => { if(s==='granted') window.addEventListener('deviceorientation', setCameraRotation); });
                } else { window.addEventListener('deviceorientation', setCameraRotation); }
                alert("è¯·å°†æ‰‹æœºæ”¾å…¥VRç›’å­ï¼Œå†æ¬¡ç‚¹å‡»å±å¹•é€€å‡º");
            } else {
                window.removeEventListener('deviceorientation', setCameraRotation);
                camera.quaternion.set(0,0,0,1);
            }
        }

        function setCameraRotation(e) {
            const alpha = THREE.MathUtils.degToRad(e.alpha);
            const beta = THREE.MathUtils.degToRad(e.beta);
            const gamma = THREE.MathUtils.degToRad(e.gamma);
            camera.quaternion.setFromEuler(new THREE.Euler(beta, alpha, -gamma, 'YXZ'));
        }

        async function switchCamera() {
            facingMode = (facingMode === "user") ? "environment" : "user";
            isMirrored = (facingMode === "user");
            videoContainer.classList.toggle('mirrored', isMirrored);
            if (cameraControl) { await cameraControl.stop(); startCamera(); }
        }

        // --- æ¸²æŸ“å¾ªç¯ (å« VR åŒçœ¼æ¸²æŸ“é€»è¾‘) ---
        function animate() {
            requestAnimationFrame(animate);
            if (!isVR) {
                renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
                renderer.setScissorTest(false);
                renderer.clear();
                renderer.render(scene, camera);
            } else {
                // VR åŒçœ¼æ¨¡å¼ï¼šæ¸²æŸ“ä¸¤æ¬¡ï¼Œåˆ†åˆ«åç½®ç›¸æœº
                const width = window.innerWidth / 2;
                const height = window.innerHeight;

                renderer.setScissorTest(true);

                // å·¦çœ¼
                renderer.setViewport(0, 0, width, height);
                renderer.setScissor(0, 0, width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.render(scene, camera);

                // å³çœ¼
                renderer.setViewport(width, 0, width, height);
                renderer.setScissor(width, 0, width, height);
                renderer.render(scene, camera);
            }
        }

        let cameraControl;
        function startCamera() {
            cameraControl = new Camera(videoElement, {
                onFrame: async () => { await hands.send({ image: videoElement }); },
                width: 1280, height: 720, facingMode: facingMode
            });
            cameraControl.start();
        }

        // é€€å‡ºVRçš„å¤‡ç”¨æ“ä½œï¼šç‚¹å‡»å±å¹•ä»»ä½•åœ°æ–¹
        window.addEventListener('click', () => { if(isVR) toggleVR(); });

        startCamera();
        animate();
    </script>
</body>
</html>
